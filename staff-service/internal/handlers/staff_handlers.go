package handlers

import (
	"context"
	"fmt"
	"log"
	"net/http"
	"os"
	"strconv"
	"time"

	"github.com/gin-gonic/gin"
	"github.com/google/uuid"
	"staff-service/internal/clients"
	"staff-service/internal/models"
	"staff-service/internal/repository"
)

type StaffHandler struct {
	repo               repository.StaffRepository
	authRepo           repository.AuthRepository
	rbacRepo           repository.RBACRepository
	notificationClient *clients.NotificationClient
}

func NewStaffHandler(repo repository.StaffRepository) *StaffHandler {
	return &StaffHandler{repo: repo}
}

// NewStaffHandlerWithAuth creates a StaffHandler with auth repository for auto-invitations
func NewStaffHandlerWithAuth(repo repository.StaffRepository, authRepo repository.AuthRepository) *StaffHandler {
	return &StaffHandler{
		repo:               repo,
		authRepo:           authRepo,
		notificationClient: clients.NewNotificationClient(),
	}
}

// NewStaffHandlerWithRBAC creates a StaffHandler with auth and RBAC repositories
// This enables auto-invitation and automatic role assignment on staff creation
func NewStaffHandlerWithRBAC(repo repository.StaffRepository, authRepo repository.AuthRepository, rbacRepo repository.RBACRepository) *StaffHandler {
	return &StaffHandler{
		repo:               repo,
		authRepo:           authRepo,
		rbacRepo:           rbacRepo,
		notificationClient: clients.NewNotificationClient(),
	}
}

// CreateStaff creates a new staff member
// @Summary Create a new staff member
// @Description Create a new staff member in the system
// @Tags staff
// @Accept json
// @Produce json
// @Param staff body models.CreateStaffRequest true "Staff data"
// @Success 201 {object} models.StaffResponse
// @Failure 400 {object} models.ErrorResponse
// @Failure 409 {object} models.ErrorResponse
// @Failure 500 {object} models.ErrorResponse
// @Security BearerAuth
// @Router /staff [post]
func (h *StaffHandler) CreateStaff(c *gin.Context) {
	tenantID := c.GetString("tenant_id")
	if tenantID == "" {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "MISSING_TENANT",
				Message: "Tenant ID is required",
			},
		})
		return
	}

	var req models.CreateStaffRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "INVALID_INPUT",
				Message: err.Error(),
			},
		})
		return
	}

	// Check if email already exists
	if existing, _ := h.repo.GetByEmail(tenantID, req.Email); existing != nil {
		c.JSON(http.StatusConflict, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "EMAIL_EXISTS",
				Message: "Staff member with this email already exists",
				Field:   "email",
			},
		})
		return
	}

	// Get vendor ID, business code, and user ID from context
	vendorID := c.GetString("vendor_id")
	businessCode := c.GetString("business_code")
	userID := c.GetString("user_id")
	if businessCode == "" {
		businessCode = "EMP" // Default business code
	}

	// Convert request to staff model
	// Note: EmployeeID is auto-generated by the system
	staff := &models.Staff{
		FirstName:        req.FirstName,
		LastName:         req.LastName,
		MiddleName:       req.MiddleName,
		DisplayName:      req.DisplayName,
		Email:            req.Email,
		AlternateEmail:   req.AlternateEmail,
		PhoneNumber:      req.PhoneNumber,
		MobileNumber:     req.MobileNumber,
		Role:             req.Role,
		EmploymentType:   req.EmploymentType,
		DepartmentID:     req.DepartmentID,
		TeamID:           req.TeamID,
		JobTitle:         req.JobTitle,
		StartDate:        req.StartDate,
		EndDate:          req.EndDate,
		ProbationEndDate: req.ProbationEndDate,
		LocationID:       req.LocationID,
		CostCenter:       req.CostCenter,
		ProfilePhotoURL:  req.ProfilePhotoURL,
		Timezone:         req.Timezone,
		Locale:           req.Locale,
		Skills:           req.Skills,
		Certifications:   req.Certifications,
		Notes:            req.Notes,
		Tags:             req.Tags,
		CustomFields:     req.CustomFields,
		CreatedBy:        &userID,
	}

	// Parse ManagerID from string to UUID if provided and not empty
	if req.ManagerID != nil && *req.ManagerID != "" {
		if managerUUID, err := uuid.Parse(*req.ManagerID); err == nil {
			staff.ManagerID = &managerUUID
		}
	}

	// Parse ProfilePhotoDocumentID from string to UUID if provided and not empty
	if req.ProfilePhotoDocumentID != nil && *req.ProfilePhotoDocumentID != "" {
		if docUUID, err := uuid.Parse(*req.ProfilePhotoDocumentID); err == nil {
			staff.ProfilePhotoDocumentID = &docUUID
		}
	}

	// STAFF-002 FIX: Set TeamUUID for proper FK relationship (used by RBAC queries)
	if req.TeamID != nil && *req.TeamID != "" {
		if teamUUID, err := uuid.Parse(*req.TeamID); err == nil {
			staff.TeamUUID = &teamUUID
		}
	}

	// Default IsActive to false - will be set to true only after account activation
	// This ensures staff shows as "Pending" until they complete activation
	if req.IsActive != nil {
		staff.IsActive = *req.IsActive
	} else {
		staff.IsActive = false
	}

	// Create staff with auto-generated employee ID
	if err := h.repo.CreateWithEmployeeID(tenantID, vendorID, businessCode, staff); err != nil {
		c.JSON(http.StatusInternalServerError, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "CREATE_FAILED",
				Message: "Failed to create staff member",
			},
		})
		return
	}

	// FIX-CRITICAL-001: Assign default role to new staff member
	// RBAC permissions are derived from staff_role_assignments only, so staff without
	// any role assignment will have zero effective permissions.
	if h.rbacRepo != nil {
		var roleAssigned bool
		var assignedRoleName string

		// Priority 1: Team's default role (if staff has a team with default role)
		if staff.TeamUUID != nil {
			team, err := h.rbacRepo.GetTeamByID(tenantID, &vendorID, *staff.TeamUUID)
			if err == nil && team != nil && team.DefaultRoleID != nil {
				assignment := &models.RoleAssignment{
					StaffID:   staff.ID,
					RoleID:    *team.DefaultRoleID,
					IsPrimary: true,
					Notes:     strPtr("Auto-assigned from team default role"),
				}
				if err := h.rbacRepo.AssignRole(tenantID, &vendorID, assignment); err == nil {
					roleAssigned = true
					if team.DefaultRole != nil {
						assignedRoleName = team.DefaultRole.Name
					}
					log.Printf("[STAFF] Assigned team default role to staff %s", staff.ID)
				}
			}
		}

		// Priority 2: Fallback to "viewer" role (lowest privilege role)
		if !roleAssigned {
			viewerRole, err := h.rbacRepo.GetRoleByName(tenantID, &vendorID, "viewer")
			if err == nil && viewerRole != nil {
				assignment := &models.RoleAssignment{
					StaffID:   staff.ID,
					RoleID:    viewerRole.ID,
					IsPrimary: true,
					Notes:     strPtr("Auto-assigned default viewer role"),
				}
				if err := h.rbacRepo.AssignRole(tenantID, &vendorID, assignment); err == nil {
					roleAssigned = true
					assignedRoleName = viewerRole.Name
					log.Printf("[STAFF] Assigned default viewer role to staff %s", staff.ID)
				}
			}
		}

		if !roleAssigned {
			log.Printf("[STAFF] WARNING: Could not assign any role to new staff %s - they will have zero permissions", staff.ID)
		} else {
			log.Printf("[STAFF] Staff %s assigned role: %s", staff.ID, assignedRoleName)
		}
	}

	// Auto-send invitation if authRepo is available
	var invitationSent bool
	var invitationToken string
	if h.authRepo != nil {
		// FIX-HIGH-005: Get SSO config to determine allowed auth methods
		// Previously hardcoded to always allow password auth, which violated SSO-only policies
		ssoConfig, _ := h.authRepo.GetSSOConfig(tenantID)

		// Build auth options based on tenant SSO policy
		authOptions := make(models.JSONArray, 0)
		if ssoConfig == nil || ssoConfig.AllowPasswordAuth {
			authOptions = append(authOptions, string(models.AuthMethodPassword))
		}
		if ssoConfig != nil && ssoConfig.GoogleEnabled {
			authOptions = append(authOptions, string(models.AuthMethodGoogleSSO))
		}
		if ssoConfig != nil && ssoConfig.MicrosoftEnabled {
			authOptions = append(authOptions, string(models.AuthMethodMicrosoftSSO))
		}

		// If no auth methods are available (misconfigured tenant), default to password
		if len(authOptions) == 0 {
			log.Printf("[STAFF] WARNING: Tenant %s has no auth methods configured, defaulting to password", tenantID)
			authOptions = append(authOptions, string(models.AuthMethodPassword))
		}

		// Create invitation
		senderUUID, _ := uuid.Parse(userID)
		invitation := &models.StaffInvitation{
			TenantID:          tenantID,
			VendorID:          &vendorID,
			StaffID:           staff.ID,
			InvitationType:    "email",
			AuthMethodOptions: &authOptions,
			SentToEmail:       &staff.Email,
			ExpiresAt:         time.Now().Add(72 * time.Hour),
			SentBy:            &senderUUID,
		}

		if err := h.authRepo.CreateInvitation(invitation); err == nil {
			// Generate activation token
			if token, err := h.authRepo.GenerateActivationToken(tenantID, staff.ID); err == nil {
				invitationToken = token
				invitationSent = true

				// Update staff status to pending activation
				_ = h.authRepo.UpdateAccountStatus(tenantID, staff.ID, models.AccountStatusPendingActivation)

				// Mark invitation as sent
				_ = h.authRepo.MarkInvitationSent(invitation.ID)

				// Send invitation email via notification service
				if h.notificationClient != nil {
					// Build activation link - use request URL if provided, otherwise fall back to env or default
					var activationBaseURL string
					if req.ActivationBaseURL != nil && *req.ActivationBaseURL != "" {
						activationBaseURL = *req.ActivationBaseURL
					} else if envHost := os.Getenv("ADMIN_HOST"); envHost != "" {
						activationBaseURL = envHost
					} else {
						// This should not happen in production - frontend should always send the URL
						log.Printf("[STAFF] Warning: No activation base URL provided, using default")
						activationBaseURL = "https://admin.tesserix.app"
					}
					activationLink := fmt.Sprintf("%s/activate?token=%s", activationBaseURL, token)

					// Get inviter name from context if available
					inviterName := c.GetString("user_name")

					// Get business name from request, fall back to context
					businessName := ""
					if req.BusinessName != nil && *req.BusinessName != "" {
						businessName = *req.BusinessName
					} else {
						businessName = c.GetString("business_name")
					}

					// Send email asynchronously
					go func() {
						// Determine role to display: prefer team's default role, fallback to staff role
						displayRole := string(staff.Role)
						if staff.TeamUUID != nil {
							if teamRoleName, err := h.repo.GetTeamDefaultRoleName(*staff.TeamUUID); err == nil && teamRoleName != "" {
								displayRole = teamRoleName
							}
						}

						notification := &clients.StaffInvitationNotification{
							TenantID:       tenantID,
							VendorID:       vendorID,
							StaffID:        staff.ID.String(),
							StaffEmail:     staff.Email,
							StaffName:      fmt.Sprintf("%s %s", staff.FirstName, staff.LastName),
							Role:           displayRole,
							InviterName:    inviterName,
							InviterID:      userID,
							BusinessName:   businessName,
							ActivationLink: activationLink,
						}
						if err := h.notificationClient.SendStaffInvitation(context.Background(), notification); err != nil {
							log.Printf("[STAFF] Failed to send invitation email to %s: %v", staff.Email, err)
						}
					}()
				}
			}
		}
	}

	// Return response with invitation info if sent
	response := gin.H{
		"success": true,
		"data":    staff,
	}
	if invitationSent {
		response["invitation"] = gin.H{
			"sent":            true,
			"activationToken": invitationToken,
			"expiresAt":       time.Now().Add(72 * time.Hour),
		}
	}

	c.JSON(http.StatusCreated, response)
}

// GetStaff retrieves a staff member by ID
// @Summary Get staff member by ID
// @Description Get a staff member by their unique identifier
// @Tags staff
// @Produce json
// @Param id path string true "Staff ID"
// @Success 200 {object} models.StaffResponse
// @Failure 404 {object} models.ErrorResponse
// @Failure 500 {object} models.ErrorResponse
// @Security BearerAuth
// @Router /staff/{id} [get]
func (h *StaffHandler) GetStaff(c *gin.Context) {
	tenantID := c.GetString("tenant_id")
	idStr := c.Param("id")

	id, err := uuid.Parse(idStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "INVALID_ID",
				Message: "Invalid staff ID format",
			},
		})
		return
	}

	staff, err := h.repo.GetByID(tenantID, id)
	if err != nil {
		c.JSON(http.StatusNotFound, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "NOT_FOUND",
				Message: "Staff member not found",
			},
		})
		return
	}

	c.JSON(http.StatusOK, models.StaffResponse{
		Success: true,
		Data:    staff,
	})
}

// GetStaffList retrieves a list of staff members
// @Summary Get staff list
// @Description Get a paginated list of staff members with optional filtering
// @Tags staff
// @Produce json
// @Param page query int false "Page number" default(1)
// @Param limit query int false "Items per page" default(20)
// @Param role query string false "Filter by role"
// @Param employment_type query string false "Filter by employment type"
// @Param department_id query string false "Filter by department"
// @Param is_active query bool false "Filter by active status"
// @Param search query string false "Search query"
// @Success 200 {object} models.StaffListResponse
// @Failure 500 {object} models.ErrorResponse
// @Security BearerAuth
// @Router /staff [get]
func (h *StaffHandler) GetStaffList(c *gin.Context) {
	tenantID := c.GetString("tenant_id")

	// Parse pagination parameters
	page, _ := strconv.Atoi(c.DefaultQuery("page", "1"))
	limit, _ := strconv.Atoi(c.DefaultQuery("limit", "20"))

	if page < 1 {
		page = 1
	}
	if limit < 1 || limit > 100 {
		limit = 20
	}

	// Check if this is a search request
	searchQuery := c.Query("search")
	if searchQuery != "" {
		staff, pagination, err := h.repo.Search(tenantID, searchQuery, page, limit)
		if err != nil {
			c.JSON(http.StatusInternalServerError, models.ErrorResponse{
				Success: false,
				Error: models.Error{
					Code:    "SEARCH_FAILED",
					Message: "Failed to search staff members",
				},
			})
			return
		}

		c.JSON(http.StatusOK, models.StaffListResponse{
			Success:    true,
			Data:       staff,
			Pagination: pagination,
		})
		return
	}

	// Parse filters
	filters := &models.StaffFilters{}

	if role := c.Query("role"); role != "" {
		filters.Roles = []models.StaffRole{models.StaffRole(role)}
	}

	if empType := c.Query("employment_type"); empType != "" {
		filters.EmploymentTypes = []models.EmploymentType{models.EmploymentType(empType)}
	}

	if deptID := c.Query("department_id"); deptID != "" {
		filters.Departments = []string{deptID}
	}

	if isActiveStr := c.Query("is_active"); isActiveStr != "" {
		if isActive, err := strconv.ParseBool(isActiveStr); err == nil {
			filters.IsActive = &isActive
		}
	}

	staff, pagination, err := h.repo.List(tenantID, filters, page, limit)
	if err != nil {
		c.JSON(http.StatusInternalServerError, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "LIST_FAILED",
				Message: "Failed to retrieve staff list",
			},
		})
		return
	}

	c.JSON(http.StatusOK, models.StaffListResponse{
		Success:    true,
		Data:       staff,
		Pagination: pagination,
	})
}

// UpdateStaff updates a staff member
// @Summary Update staff member
// @Description Update an existing staff member
// @Tags staff
// @Accept json
// @Produce json
// @Param id path string true "Staff ID"
// @Param staff body models.UpdateStaffRequest true "Updated staff data"
// @Success 200 {object} models.StaffResponse
// @Failure 400 {object} models.ErrorResponse
// @Failure 404 {object} models.ErrorResponse
// @Failure 500 {object} models.ErrorResponse
// @Security BearerAuth
// @Router /staff/{id} [put]
func (h *StaffHandler) UpdateStaff(c *gin.Context) {
	tenantID := c.GetString("tenant_id")
	idStr := c.Param("id")

	id, err := uuid.Parse(idStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "INVALID_ID",
				Message: "Invalid staff ID format",
			},
		})
		return
	}

	var req models.UpdateStaffRequest
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "INVALID_INPUT",
				Message: err.Error(),
			},
		})
		return
	}

	// Check if staff exists
	existing, err := h.repo.GetByID(tenantID, id)
	if err != nil {
		c.JSON(http.StatusNotFound, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "NOT_FOUND",
				Message: "Staff member not found",
			},
		})
		return
	}

	// STAFF-002 FIX: Convert TeamID to TeamUUID for proper FK relationship
	if req.TeamID != nil {
		if *req.TeamID != "" {
			if teamUUID, err := uuid.Parse(*req.TeamID); err == nil {
				req.TeamUUID = &teamUUID
			}
		} else {
			// TeamID is explicitly empty - clear TeamUUID too
			req.TeamUUID = nil
		}
	}

	// Check for email conflicts (if email is being updated)
	if req.Email != nil && *req.Email != existing.Email {
		if conflict, _ := h.repo.GetByEmail(tenantID, *req.Email); conflict != nil {
			c.JSON(http.StatusConflict, models.ErrorResponse{
				Success: false,
				Error: models.Error{
					Code:    "EMAIL_EXISTS",
					Message: "Another staff member with this email already exists",
					Field:   "email",
				},
			})
			return
		}
	}

	if err := h.repo.Update(tenantID, id, &req); err != nil {
		c.JSON(http.StatusInternalServerError, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "UPDATE_FAILED",
				Message: "Failed to update staff member",
			},
		})
		return
	}

	// Fetch updated staff
	updatedStaff, _ := h.repo.GetByID(tenantID, id)

	c.JSON(http.StatusOK, models.StaffResponse{
		Success: true,
		Data:    updatedStaff,
	})
}

// DeleteStaff soft deletes a staff member
// @Summary Delete staff member
// @Description Soft delete a staff member (marks as deleted)
// @Tags staff
// @Produce json
// @Param id path string true "Staff ID"
// @Success 200 {object} models.StaffResponse
// @Failure 404 {object} models.ErrorResponse
// @Failure 500 {object} models.ErrorResponse
// @Security BearerAuth
// @Router /staff/{id} [delete]
func (h *StaffHandler) DeleteStaff(c *gin.Context) {
	tenantID := c.GetString("tenant_id")
	idStr := c.Param("id")

	id, err := uuid.Parse(idStr)
	if err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "INVALID_ID",
				Message: "Invalid staff ID format",
			},
		})
		return
	}

	// Check if staff exists
	_, err = h.repo.GetByID(tenantID, id)
	if err != nil {
		c.JSON(http.StatusNotFound, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "NOT_FOUND",
				Message: "Staff member not found",
			},
		})
		return
	}

	// Cleanup related records (invitations, sessions, audit logs) before deleting
	if h.authRepo != nil {
		if err := h.authRepo.CleanupStaffRecords(tenantID, id); err != nil {
			c.JSON(http.StatusInternalServerError, models.ErrorResponse{
				Success: false,
				Error: models.Error{
					Code:    "CLEANUP_FAILED",
					Message: "Failed to cleanup related records",
				},
			})
			return
		}
	}

	if err := h.repo.Delete(tenantID, id, tenantID); err != nil {
		c.JSON(http.StatusInternalServerError, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "DELETE_FAILED",
				Message: "Failed to delete staff member",
			},
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"message": "Staff member deleted successfully",
	})
}

// BulkCreateStaff creates multiple staff members
// @Summary Bulk create staff members
// @Description Create multiple staff members in a single request
// @Tags staff
// @Accept json
// @Produce json
// @Param staff body []models.CreateStaffRequest true "Array of staff data"
// @Success 201 {object} models.StaffListResponse
// @Failure 400 {object} models.ErrorResponse
// @Failure 500 {object} models.ErrorResponse
// @Security BearerAuth
// @Router /staff/bulk [post]
func (h *StaffHandler) BulkCreateStaff(c *gin.Context) {
	tenantID := c.GetString("tenant_id")

	var requests []models.CreateStaffRequest
	if err := c.ShouldBindJSON(&requests); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "INVALID_INPUT",
				Message: err.Error(),
			},
		})
		return
	}

	if len(requests) == 0 {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "EMPTY_REQUEST",
				Message: "No staff members provided",
			},
		})
		return
	}

	if len(requests) > 100 {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "TOO_MANY_ITEMS",
				Message: "Maximum 100 staff members can be created at once",
			},
		})
		return
	}

	// Get vendor ID, business code, and user ID from context
	vendorID := c.GetString("vendor_id")
	businessCode := c.GetString("business_code")
	userID := c.GetString("user_id")
	if businessCode == "" {
		businessCode = "EMP" // Default business code
	}

	// Convert requests to staff models
	// Note: EmployeeIDs are auto-generated
	staffList := make([]*models.Staff, 0, len(requests))
	for _, req := range requests {
		staff := &models.Staff{
			FirstName:        req.FirstName,
			LastName:         req.LastName,
			MiddleName:       req.MiddleName,
			DisplayName:      req.DisplayName,
			Email:            req.Email,
			AlternateEmail:   req.AlternateEmail,
			PhoneNumber:      req.PhoneNumber,
			MobileNumber:     req.MobileNumber,
			Role:             req.Role,
			EmploymentType:   req.EmploymentType,
			DepartmentID:     req.DepartmentID,
			TeamID:           req.TeamID,
			JobTitle:         req.JobTitle,
			StartDate:        req.StartDate,
			EndDate:          req.EndDate,
			ProbationEndDate: req.ProbationEndDate,
			LocationID:       req.LocationID,
			CostCenter:       req.CostCenter,
			ProfilePhotoURL:  req.ProfilePhotoURL,
			Timezone:         req.Timezone,
			Locale:           req.Locale,
			Skills:           req.Skills,
			Certifications:   req.Certifications,
			Notes:            req.Notes,
			Tags:             req.Tags,
			CustomFields:     req.CustomFields,
			CreatedBy:        &userID,
		}

		// Parse ManagerID from string to UUID if provided and not empty
		if req.ManagerID != nil && *req.ManagerID != "" {
			if managerUUID, err := uuid.Parse(*req.ManagerID); err == nil {
				staff.ManagerID = &managerUUID
			}
		}

		// Parse ProfilePhotoDocumentID from string to UUID if provided and not empty
		if req.ProfilePhotoDocumentID != nil && *req.ProfilePhotoDocumentID != "" {
			if docUUID, err := uuid.Parse(*req.ProfilePhotoDocumentID); err == nil {
				staff.ProfilePhotoDocumentID = &docUUID
			}
		}

		// STAFF-002 FIX: Set TeamUUID for proper FK relationship (used by RBAC queries)
		if req.TeamID != nil && *req.TeamID != "" {
			if teamUUID, err := uuid.Parse(*req.TeamID); err == nil {
				staff.TeamUUID = &teamUUID
			}
		}

		// Default IsActive to false - will be set to true only after account activation
		if req.IsActive != nil {
			staff.IsActive = *req.IsActive
		} else {
			staff.IsActive = false
		}

		staffList = append(staffList, staff)
	}

	// Bulk create with auto-generated employee IDs
	result, err := h.repo.BulkCreateWithEmployeeIDs(tenantID, vendorID, businessCode, staffList, false)
	if err != nil {
		c.JSON(http.StatusInternalServerError, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "BULK_CREATE_FAILED",
				Message: "Failed to create staff members",
			},
		})
		return
	}

	// Convert created staff to slice for response
	createdStaff := make([]models.Staff, len(result.Created))
	for i, s := range result.Created {
		createdStaff[i] = *s
	}

	c.JSON(http.StatusCreated, models.StaffListResponse{
		Success: true,
		Data:    createdStaff,
	})
}

// BulkUpdateStaff updates multiple staff members
// @Summary Bulk update staff members
// @Description Update multiple staff members in a single request
// @Tags staff
// @Accept json
// @Produce json
// @Param updates body []models.UpdateStaffRequest true "Array of staff updates"
// @Success 200 {object} gin.H
// @Failure 400 {object} models.ErrorResponse
// @Failure 500 {object} models.ErrorResponse
// @Security BearerAuth
// @Router /staff/bulk [put]
func (h *StaffHandler) BulkUpdateStaff(c *gin.Context) {
	tenantID := c.GetString("tenant_id")

	var updates []models.UpdateStaffRequest
	if err := c.ShouldBindJSON(&updates); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "INVALID_INPUT",
				Message: err.Error(),
			},
		})
		return
	}

	if err := h.repo.BulkUpdate(tenantID, updates); err != nil {
		c.JSON(http.StatusInternalServerError, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "BULK_UPDATE_FAILED",
				Message: "Failed to update staff members",
			},
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"message": "Staff members updated successfully",
	})
}

// ExportStaff exports staff data
// @Summary Export staff data
// @Description Export staff data in various formats
// @Tags staff
// @Produce json
// @Param format query string false "Export format (json, csv)" default(json)
// @Success 200 {object} gin.H
// @Failure 500 {object} models.ErrorResponse
// @Security BearerAuth
// @Router /staff/export [post]
func (h *StaffHandler) ExportStaff(c *gin.Context) {
	tenantID := c.GetString("tenant_id")
	format := c.DefaultQuery("format", "json")

	// For now, just return the data in JSON format
	// In a real implementation, you'd generate CSV/Excel files
	staff, _, err := h.repo.List(tenantID, nil, 1, 1000) // Export up to 1000 records
	if err != nil {
		c.JSON(http.StatusInternalServerError, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "EXPORT_FAILED",
				Message: "Failed to export staff data",
			},
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"success":     true,
		"format":      format,
		"data":        staff,
		"count":       len(staff),
		"exported_at": time.Now(),
	})
}

// GetStaffAnalytics gets analytics data
// @Summary Get staff analytics
// @Description Get analytics and statistics about staff
// @Tags staff
// @Produce json
// @Success 200 {object} gin.H
// @Failure 500 {object} models.ErrorResponse
// @Security BearerAuth
// @Router /staff/analytics [get]
func (h *StaffHandler) GetStaffAnalytics(c *gin.Context) {
	tenantID := c.GetString("tenant_id")

	analytics, err := h.repo.GetAnalytics(tenantID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "ANALYTICS_FAILED",
				Message: "Failed to retrieve analytics",
			},
		})
		return
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"data":    analytics,
	})
}

// GetStaffHierarchy gets organizational hierarchy
// @Summary Get staff hierarchy
// @Description Get organizational hierarchy starting from a manager
// @Tags staff
// @Produce json
// @Param manager_id query string false "Manager ID to start hierarchy from"
// @Success 200 {object} models.StaffListResponse
// @Failure 500 {object} models.ErrorResponse
// @Security BearerAuth
// @Router /staff/hierarchy [get]
func (h *StaffHandler) GetStaffHierarchy(c *gin.Context) {
	tenantID := c.GetString("tenant_id")
	managerIDStr := c.Query("manager_id")

	var managerID *uuid.UUID
	if managerIDStr != "" {
		if id, err := uuid.Parse(managerIDStr); err == nil {
			managerID = &id
		}
	}

	staff, err := h.repo.GetHierarchy(tenantID, managerID)
	if err != nil {
		c.JSON(http.StatusInternalServerError, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "HIERARCHY_FAILED",
				Message: "Failed to retrieve hierarchy",
			},
		})
		return
	}

	c.JSON(http.StatusOK, models.StaffListResponse{
		Success: true,
		Data:    staff,
	})
}

// GetStaffTenantsInternal returns all tenants a staff member has access to
// This is an internal endpoint called by tenant-service for /users/me/tenants
// The ID here is the Keycloak user ID (x-jwt-claim-sub), not internal staff ID
// GET /api/v1/internal/staff/:id/tenants
func (h *StaffHandler) GetStaffTenantsInternal(c *gin.Context) {
	keycloakUserID := c.Param("id")
	if keycloakUserID == "" {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "MISSING_ID",
				Message: "User ID is required",
			},
		})
		return
	}

	// Get all staff records for this Keycloak user ID across all tenants
	staffList, err := h.repo.GetAllByKeycloakUserID(keycloakUserID)
	if err != nil {
		log.Printf("[STAFF] Error getting staff tenants for Keycloak ID %s: %v", keycloakUserID, err)
		c.JSON(http.StatusOK, gin.H{
			"success": true,
			"data": gin.H{
				"tenants": []interface{}{},
				"count":   0,
			},
		})
		return
	}

	// Build tenant list with same structure as GetStaffTenants
	tenants := make([]gin.H, 0, len(staffList))
	for _, staff := range staffList {
		tenants = append(tenants, gin.H{
			"id":           staff.TenantID,
			"staff_id":     staff.ID,
			"role":         staff.Role,
			"vendor_id":    staff.VendorID,
			"display_name": fmt.Sprintf("%s %s", staff.FirstName, staff.LastName),
		})
	}

	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"data": gin.H{
			"tenants": tenants,
			"count":   len(tenants),
		},
	})
}

// GetStaffByEmailInternal returns staff info by email for a specific tenant
// This is an internal endpoint called by tenant-service for credential validation
// GET /api/v1/internal/staff/by-email?email=xxx
func (h *StaffHandler) GetStaffByEmailInternal(c *gin.Context) {
	tenantIDVal, _ := c.Get("tenant_id")
	tenantID := ""
	if tenantIDVal != nil {
		tenantID = tenantIDVal.(string)
	}
	if tenantID == "" {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "MISSING_TENANT",
				Message: "tenant_id is required",
			},
		})
		return
	}

	email := c.Query("email")
	if email == "" {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "MISSING_EMAIL",
				Message: "email query parameter is required",
			},
		})
		return
	}

	staff, err := h.repo.GetByEmail(tenantID, email)
	if err != nil {
		c.JSON(http.StatusNotFound, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "STAFF_NOT_FOUND",
				Message: "Staff member not found",
			},
		})
		return
	}

	// Return only the fields needed for credential validation
	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"data": gin.H{
			"staff": gin.H{
				"id":               staff.ID,
				"email":            staff.Email,
				"first_name":       staff.FirstName,
				"last_name":        staff.LastName,
				"keycloak_user_id": staff.KeycloakUserID,
				"tenant_id":        staff.TenantID,
				"account_status":   staff.AccountStatus,
				"is_active":        staff.IsActive,
			},
		},
	})
}

// SyncKeycloakUserIDInternal syncs the keycloak_user_id for a staff member
// POST /api/v1/internal/staff/sync-keycloak-id
// This is called after successful Keycloak login to ensure the keycloak_user_id matches
func (h *StaffHandler) SyncKeycloakUserIDInternal(c *gin.Context) {
	tenantIDVal, _ := c.Get("tenant_id")
	tenantID := ""
	if tenantIDVal != nil {
		tenantID = tenantIDVal.(string)
	}
	if tenantID == "" {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "MISSING_TENANT",
				Message: "tenant_id is required",
			},
		})
		return
	}

	var req struct {
		StaffID        string `json:"staff_id" binding:"required"`
		KeycloakUserID string `json:"keycloak_user_id" binding:"required"`
	}
	if err := c.ShouldBindJSON(&req); err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "INVALID_INPUT",
				Message: err.Error(),
			},
		})
		return
	}

	staffID, err := uuid.Parse(req.StaffID)
	if err != nil {
		c.JSON(http.StatusBadRequest, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "INVALID_STAFF_ID",
				Message: "Invalid staff ID format",
			},
		})
		return
	}

	// Update keycloak_user_id
	if err := h.repo.UpdateKeycloakUserID(tenantID, staffID, req.KeycloakUserID); err != nil {
		log.Printf("[STAFF] Failed to sync keycloak_user_id for staff %s: %v", staffID, err)
		c.JSON(http.StatusInternalServerError, models.ErrorResponse{
			Success: false,
			Error: models.Error{
				Code:    "UPDATE_FAILED",
				Message: "Failed to sync Keycloak user ID",
			},
		})
		return
	}

	log.Printf("[STAFF] Synced keycloak_user_id for staff %s to %s", staffID, req.KeycloakUserID)
	c.JSON(http.StatusOK, gin.H{
		"success": true,
		"message": "Keycloak user ID synced successfully",
	})
}

// strPtr returns a pointer to a string
func strPtr(s string) *string {
	return &s
}
